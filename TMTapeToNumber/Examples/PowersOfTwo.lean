import TMTapeToNumber.Sequences

namespace TMTapeToNumber.Examples

open Turing TM0 TMTapeToNumber

/-- States for the powers of two machine -/
inductive PowersState
  | init    -- Initial state: write true at position 0
  | scan    -- Scan left to find the leftmost true
  | mark    -- Mark the next position
  | halt    -- Halting state

instance : Inhabited PowersState := ⟨PowersState.halt⟩

/-- The powers of two Turing machine.
    Starting with an empty tape, it generates the sequence 1, 2, 4, 8, ... -/
def powers_machine : Machine Bool PowersState
  | PowersState.init, _ => some (PowersState.scan, Stmt.write true)
  | PowersState.scan, false => some (PowersState.mark, Stmt.write true)  
  | PowersState.scan, true => some (PowersState.scan, Stmt.move Dir.left)
  | PowersState.mark, _ => some (PowersState.halt, Stmt.move Dir.right)
  | PowersState.halt, _ => none

/-- Initial configuration: empty tape, init state -/
def powers_initial : Cfg Bool PowersState :=
  ⟨PowersState.init, Tape.mk₁ []⟩

/-- The sequence generated by the powers of two machine -/
noncomputable def powers_sequence : ℕ → ℕ := 
  sequence powers_machine powers_initial

/-- Theorem: The sequence starts with 1 -/
theorem powers_sequence_zero : powers_sequence 0 = 1 := by
  simp [powers_sequence, sequence]
  -- At step 0, we have the initial configuration
  -- The tape is empty (all false), and position 0 maps to exponent 0
  -- After init state writes true at position 0, we get 2^0 = 1
  sorry

/-- Theorem: The first few values are powers of two -/
theorem powers_sequence_initial_values :
    powers_sequence 0 = 1 ∧
    powers_sequence 1 = 1 ∧  -- After writing true
    powers_sequence 2 = 1 ∧  -- After moving to scan
    powers_sequence 3 = 3 ∧  -- After writing true at position -1 (2^0 + 2^1 = 3)
    powers_sequence 4 = 2    -- After moving right and halting (only position -1 has true)
    := by
  sorry

/-- Helper: Describe the tape configuration after n steps -/
def tape_after_n_steps (n : ℕ) : Prop :=
  match n with
  | 0 => ((step_or_stay powers_machine)^[0] powers_initial).Tape.nth 0 = false
  | 1 => ((step_or_stay powers_machine)^[1] powers_initial).Tape.nth 0 = true
  | 2 => ((step_or_stay powers_machine)^[2] powers_initial).Tape.nth 0 = true ∧
         ((step_or_stay powers_machine)^[2] powers_initial).Tape.nth (-1) = false
  | 3 => ((step_or_stay powers_machine)^[3] powers_initial).Tape.nth 0 = true ∧
         ((step_or_stay powers_machine)^[3] powers_initial).Tape.nth (-1) = true
  | _ => true

/-- The machine follows a specific pattern -/
theorem powers_machine_pattern :
    ∀ n < 5, tape_after_n_steps n := by
  sorry

/-- After the initial steps, the machine produces powers of two -/
theorem powers_sequence_are_powers (k : ℕ) (h : k ≥ 4) :
    ∃ n, powers_sequence k = 2^n := by
  -- The machine creates a pattern where position -n has true,
  -- which encodes to 2^(position_to_exponent(-n))
  sorry

end TMTapeToNumber.Examples