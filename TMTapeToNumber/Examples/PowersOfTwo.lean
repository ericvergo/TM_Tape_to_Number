import TMTapeToNumber.LeftwardSequences.Basic
import TMTapeToNumber.BinaryStepSequences.Basic
import TMTapeToNumber.BinaryStepSequences.Theorems

/-!
# Powers of Two Example

This module demonstrates a simple Turing machine that generates the sequence
1, 3, 7, 15, 31, ... (numbers of the form 2^n - 1).

The machine works by:
1. Starting with an empty tape
2. Writing `true` at position 0 
3. Repeatedly finding the leftmost `true` and writing another `true` to its left
4. This creates a growing block of `true` values: [T], [T,T], [T,T,T], ...
5. The encoding gives us: 2^0 = 1, 2^0 + 2^1 = 3, 2^0 + 2^1 + 2^2 = 7, ...
-/

namespace TMTapeToNumber.Examples

open Turing LeftTM0 LeftTM0.Theorems

/-- States for the powers of two machine -/
inductive PowersState
  | init    -- Initial state: write true at position 0
  | scan    -- Scan left to find the leftmost true
  | mark    -- Mark the next position
  | halt    -- Halting state (not used in this infinite machine)
  deriving DecidableEq

instance : Inhabited PowersState := ⟨PowersState.halt⟩

/-- The powers of two minus one Turing machine.
    Starting with an empty tape, it generates the sequence 1, 3, 7, 15, 31, ... -/
def powers_of_two_machine : LeftTM0.Machine Bool PowersState
  | PowersState.init, _ => some (PowersState.scan, TM0.Stmt.write true)
  | PowersState.scan, false => some (PowersState.mark, TM0.Stmt.write true)  
  | PowersState.scan, true => some (PowersState.scan, TM0.Stmt.move Dir.left)
  | PowersState.mark, _ => some (PowersState.scan, TM0.Stmt.move Dir.right)
  | PowersState.halt, _ => none

/-- Initial configuration: empty tape, init state -/
def powers_initial : LeftTM0.Cfg Bool PowersState :=
  ⟨PowersState.init, LeftwardTape.mk_initial []⟩

/-- The sequence generated by the powers of two machine -/
noncomputable def powers_sequence : ℕ → ℕ := 
  LeftTM0.sequence powers_of_two_machine powers_initial

/-- The first few values of the sequence are correct -/
example : powers_sequence 0 = 0 := by
  simp [powers_sequence, LeftTM0.sequence, sequence_zero, powers_initial]
  -- sequence_zero shows this is encode_config of initial config
  -- Now we need to show (steps M 0 init_cfg).tape.encode = 0
  simp [steps, Function.iterate_zero_apply]
  -- This reduces to showing powers_initial.tape.encode = 0
  rw [encode_config]
  -- powers_initial has empty tape
  simp [powers_initial]
  exact encode_empty_tape

example : powers_sequence 1 = 1 := by
  sorry -- After first step: tape has [true] at position 0, encoding to 2^0 = 1

example : powers_sequence 2 = 1 := by
  sorry -- Still scanning left, no change

example : powers_sequence 3 = 3 := by
  sorry -- After marking: tape has [true, true] at positions -1, 0, encoding to 2^0 + 2^1 = 3

/-- The powers of two machine never terminates -/
theorem powers_machine_never_halts (t : ℕ) :
    ¬is_terminal powers_of_two_machine (steps powers_of_two_machine t powers_initial) := by
  sorry

/-- The sequence generated is indeed 2^n - 1 for appropriate steps -/
theorem powers_sequence_formula (n : ℕ) :
    ∃ t : ℕ, powers_sequence t = 2^n - 1 := by
  sorry

/-- This machine generates a binary step sequence -/
theorem powers_is_binary_step_sequence :
    is_binary_step_sequence powers_sequence := by
  -- Need to provide correct arguments to tm_sequence_is_binary_step_sequence
  -- The theorem expects init_cfg = init [] but our powers_initial has a different state
  -- Let's use a different approach
  sorry

end TMTapeToNumber.Examples