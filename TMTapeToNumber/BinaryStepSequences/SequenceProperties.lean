/-
Copyright (c) 2024 Lean FRO, LLC. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: The Lean FRO Team
-/
import TMTapeToNumber.BinaryStepSequences.EncodingProperties
import TMTapeToNumber.BinaryStepSequences.EncodingDifference
import TMTapeToNumber.LeftTM0.Step

/-!
# Properties of TM Sequences

This file contains lemmas about properties of sequences generated by
Turing machines, including the key result that sequence differences
are powers of two.
-/

set_option linter.unusedSectionVars false

namespace LeftTM0

namespace BinaryStepSequences

variable {Λ : Type*} [Inhabited Λ]

open Turing LeftTM0 LeftwardTape

/-- Integer difference between consecutive sequence values -/
noncomputable def sequence_diff (M : Machine Bool Λ) (init_cfg : Cfg Bool Λ) (t : ℕ) : ℤ :=
  (sequence M init_cfg (t + 1) : ℤ) - (sequence M init_cfg t : ℤ)

/-- One step of a TM changes the encoding by 0 or ±2^k -/
lemma sequence_diff_is_power_of_two (M : Machine Bool Λ) (init_cfg : Cfg Bool Λ) (t : ℕ) :
    let diff := sequence_diff M init_cfg t
    diff = 0 ∨ ∃ k : ℕ, diff = 2^k ∨ diff = -(2^k : ℤ) := by
  sorry

/-- Helper: The encoding change from step_or_stay matches the head position -/
lemma encode_change_from_step (M : Machine Bool Λ) (cfg : Cfg Bool Λ)
    (h_cont : ¬is_terminal M cfg) :
    let cfg' := step_or_stay M cfg
    let diff := encode_diff cfg cfg'
    diff = 0 ∨ ∃ k : ℕ, diff = 2^k ∨ diff = -(2^k : ℤ) := by
  sorry

/-- The k value in a sequence change equals the absolute position where the write occurred -/
lemma sequence_k_equals_position (M : Machine Bool Λ) (init_cfg : Cfg Bool Λ) (t : ℕ)
    (h_cont : ¬is_terminal M (steps M t init_cfg))
    (h_change : sequence M init_cfg t ≠ sequence M init_cfg (t + 1)) :
    ∃ k : ℕ, (sequence_diff M init_cfg t = 2^k ∨ sequence_diff M init_cfg t = -(2^k : ℤ)) ∧
              k = Int.natAbs (-(steps M t init_cfg).tape.head_pos) := by
  sorry

/-- Movement constraint between k values -/
lemma sequence_k_movement_constraint (M : Machine Bool Λ) (init_cfg : Cfg Bool Λ) (i j : ℕ)
    (hi : i < j)
    (h_cont_i : ¬is_terminal M (steps M i init_cfg))
    (h_cont_j : ¬is_terminal M (steps M j init_cfg))
    (ki kj : ℕ)
    (h_ki : sequence_diff M init_cfg i = 2^ki ∨ sequence_diff M init_cfg i = -(2^ki : ℤ))
    (h_kj : sequence_diff M init_cfg j = 2^kj ∨ sequence_diff M init_cfg j = -(2^kj : ℤ)) :
    ki ≤ kj + (j - i) ∧ kj ≤ ki + (j - i) := by
  sorry

end BinaryStepSequences

end LeftTM0