\documentclass[11pt]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{tikz}
\usepackage[margin=1in]{geometry}
\usepackage{algorithm}
\usepackage{algorithmic}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{conjecture}[theorem]{Conjecture}

\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}

\theoremstyle{remark}
\newtheorem{remark}[theorem]{Remark}

\title{Integer Sequences from Turing Machine Tapes}
\author{Eric Vergo \\ ericvergo@gmail.com}
\date{Jun. 28, 2025}

\begin{document}

\maketitle

\begin{abstract}
We introduce a method for converting Turing machine execution traces into integer sequences by interpreting tape contents as binary numbers. Using a Turing Machine with a left-unbounded tape, we provide a characterization of the resulting sequences, which we term \emph{binary step sequences}. The definition of these sequences rigorously encodes and positional constraints generated by the movement of the head. We investigate this characterization in both directions, and draw an exact correspondence for finite sequences. In addition we offer conjectures and ideas for further study. Although the results presented here are not of obvious consequence, the hope is that this construction opens new avenues for studying Turing machine behavior.


\end{abstract}

\section{Introduction}

We present a construction that systematically converts Turing machine (TM) execution traces into integer sequences. By interpreting the tape contents as a binary number at each computational step, we generate sequences that directly reflect the underlying computation. Our model uses a tape that is unbounded to the left, initiated with all zeros, creating a natural correspondence between the bits on the tape and the coefficients of a binary expansion.

This approach differs from existing work in several key aspects. While the busy beaver literature has extensively analyzed tape evolution and complexity metrics \cite{marxen1990,michel2015}, its focus has been on optimizing for specific behaviors rather than characterizing the full class of possible output sequences. Similarly, the theory of automatic sequences studies sequences generated by finite automata \cite{allouche2003}, which are less computationally powerful than Turing machines. Our work can be seen as a natural extension, exploring sequences generated by a universal model of computation, as first formalized by Turing \cite{turing1936}. By focusing on the structural properties imposed by the TM's mechanical nature, we derive a complete characterization for the finite case.

\section{The Basic Construction}

We begin by formally defining our encoding from a Turing machine's tape to an integer sequence.

\begin{definition}[TM-to-Integer Encoding]
\label{def:encoding}
Consider a Turing machine $M$ with:
\begin{itemize}
\item A tape unbounded to the left, with cells indexed by non-negative integers $0, 1, 2, \ldots$
\item A binary tape alphabet $\{0, 1\}$
\item An initial tape configuration where all cells contain $0$
\item A read/write head starting at position $0$
\end{itemize}
Let $T_t(i)$ be the content of tape cell $i$ at time step $t \geq 0$. The integer sequence $(s_t)_{t \geq 0}$ generated by $M$ is defined by:
$$s_t = \sum_{i=0}^{\infty} T_t(i) \cdot 2^i$$
We denote the head's position at the beginning of step $t$ (i.e., before the transition from $t$ to $t+1$) as $p_t$.
\end{definition}

This sum is well-defined because a TM can only write on a finite portion of the tape in a finite number of steps.

\begin{example}
Consider a tape configuration where the head is at position 4. Note that the representation is independent of the head position, and is fully defined by the contents of the tape:
\begin{center}
\begin{tikzpicture}[scale=0.7]
\foreach \x in {0,...,7} {
    \draw (\x,0) rectangle (\x+1,1);
}
\node at (0.5,0.5) {0};
\node at (1.5,0.5) {1};
\node at (2.5,0.5) {0};
\node at (3.5,0.5) {0};
\node at (4.5,0.5) {1};
\node at (5.5,0.5) {1};
\node at (6.5,0.5) {0};
\node at (7.5,0.5) {1};
\node at (-0.7,0.33) {$\cdots$};
\draw[thick,->] (4.5,1.5) -- (4.5,1.1);
\node at (4.5,1.8) {\small \{head\}};
\end{tikzpicture}

\small This configuration represents $\dots 01001101_2 = 77_{10}$.
\end{center}
\end{example}

\section{Structural Properties}

The sequences generated TMs are highly structured and defined by the physical movement of the TM head, which can only modify one bit each step, at one location each step, and move a single cell at each step.

\begin{definition}[Binary Step Sequence]
\label{def:bss}
A sequence $(s_t)_{t\geq0}$ is a \emph{binary step sequence} if it meets all of the following conditions:
\begin{enumerate}
\item $s_0 = 0$.
\item For each step $t \geq 0$, the difference $\delta_t = s_{t+1} - s_t$ is either $0$ or has the form $\pm 2^k$ for some non-negative integer $k$.
\item Let $I = \{t \geq 0 \mid \delta_t \neq 0\}$ be the set of indices where the sequence changes. For each $t \in I$, define $k_t = \log_2 |\delta_t|$. The following must hold:
    \begin{enumerate}
    \item For every $t \in I$, we must have $k_t \leq t$. This reflects that the head, starting at position 0, can reach at most position $t$ after $t$ steps.
    \item For any two indices $i, j \in I$ with $i < j$, we must have $|k_j - k_i| \leq j - i$. This constrains the head's movement between any two write operations.
    \end{enumerate}
\end{enumerate}
\end{definition}

These conditions lead to our first main result, which shows that all TM-generated sequences have this structure.

\begin{theorem}[Forward Characterization]
Every TM-generated sequence is a binary step sequence.
\end{theorem}

\begin{proof}
Let $(s_t)$ be a sequence generated by a TM according to Definition \ref{def:encoding}.
\begin{enumerate}
\item The initial tape is all zeros, so $s_0 = \sum_{i=0}^\infty 0 \cdot 2^i = 0$.
\item At step $t$, the TM is at position $p_t$. It reads the bit $b = T_t(p_t)$ and writes a new bit $b'$. The change in the integer value is $(b' - b) \cdot 2^{p_t}$. Since $b, b' \in \{0, 1\}$, this difference is either $0$, $2^{p_t}$ (if $b=0, b'=1$), or $-2^{p_t}$ (if $b=1, b'=0$). This satisfies condition 2, with $k = p_t$.
\item Let $I$ be the set of steps with non-zero changes. For any $t \in I$, the change occurs at the head position $p_t$, so $|s_{t+1} - s_t| = 2^{p_t}$. This implies $k_t = p_t$ for all $t \in I$. We must verify the conditions on $(k_t)$, which are now conditions on the head path $(p_t)$.
    \begin{enumerate}
    \item The head starts at $p_0=0$ and at each step can move at most one position. Therefore, after $t$ steps, its position $p_t$ is at most $t$. Thus, $k_t = p_t \leq t$.
    \item For any $i, j \in I$ with $i < j$, the head moves from position $p_i$ to $p_j$ in $j-i$ steps. The maximum distance it can travel is $j-i$. Therefore, $|p_j - p_i| \leq j-i$. Substituting $p_t=k_t$, we get $|k_j - k_i| \leq j-i$.
    \end{enumerate}
\end{enumerate}
Thus, any TM-generated sequence satisfies all conditions of a binary step sequence.
\end{proof}

An immediate consequence of the definition is a tight bound on the growth of the sequence.

\begin{theorem}[Sequence Growth Bound]
If $(s_t)_{t \geq 0}$ is a binary step sequence, then for any $t \geq 0$, we have $s_t < 2^{t+1}$.
\end{theorem}

\begin{proof}
At any time $t$, the set of tape positions that could possibly have been written to are $\{0, 1, \ldots, t\}$, since the head starts at $p_0=0$ and can move at most one position per step. Therefore, for any $i > t$, the tape cell at position $i$ must contain its initial value of $0$. The maximum possible value for $s_t$ occurs if all reachable tape cells contain a '1':
$$s_t \leq \sum_{i=0}^{t} 1 \cdot 2^i = 2^{t+1} - 1$$
Thus, $s_t < 2^{t+1}$.
\end{proof}

\section{Universality Results}

The definition of a \emph{finite} binary step sequence is not just a property of TM-generated sequences; it is a complete characterization. Every \emph{finite} sequence satisfying these conditions can be realized by a Turing machine.

\begin{theorem}[Finite Sequence Generation]
Every finite binary step sequence is TM-generable.
\end{theorem}

\begin{proof}
Let $S = (s_0, s_1, \ldots, s_n)$ be a finite binary step sequence. We must construct a TM that generates it. This requires defining a valid head path $(p_0, p_1, \ldots, p_{n-1})$ that is consistent with the sequence properties.

First, we define the head path at moments of writing. Let $I = \{t \in [0, n-1] \mid s_{t+1} \neq s_t\}$, and let $k_t = \log_2|s_{t+1} - s_t|$ for $t \in I$. A consistent head path must have $p_t = k_t$ for all $t \in I$.

Next, we construct the full path by defining $p_t$ for $t \notin I$. Consider any two consecutive indices $i, j$ in the augmented set $I' = I \cup \{-1, n\}$, where we define $k_{-1} = 0$. For any $t$ such that $i < t < j$, we must define a path from $p_i=k_i$ to $p_j=k_j$ in $j-i$ steps. By Definition \ref{def:bss}.3(b), we know $|k_j - k_i| \leq j-i$. This guarantees that such a path exists. For instance, a valid path moves one unit towards $k_j$ for $|k_j - k_i|$ steps, and then stays put for the remaining $j - i - |k_j - k_i|$ steps. This constructs a complete and valid head path $(p_0, \ldots, p_{n-1})$ where $|p_{t+1} - p_t| \leq 1$ for all $t$.

With this path, we construct the TM. The TM has $n+1$ states, $q_0, \ldots, q_n$, where $q_n$ is the halt state. For each $t$ from $0$ to $n-1$, state $q_t$ is designed to perform step $t$ of the computation:
\begin{enumerate}
\item In state $q_t$, the TM reads the bit at position $p_t$.
\item If $t \in I$, it writes '1' if $s_{t+1} - s_t > 0$ and '0' if $s_{t+1} - s_t < 0$. If $t \notin I$, it writes back the same bit it read.
\item It moves the head according to the pre-defined path: left if $p_{t+1}-p_t = -1$, right if $p_{t+1}-p_t=1$, and no move if $p_{t+1}-p_t=0$.
\item It transitions to state $q_{t+1}$.
\end{enumerate}
This machine, by construction, faithfully reproduces the sequence $S$.
\end{proof}

\begin{conjecture}
Not every infinite binary step sequence is TM-generable.
\end{conjecture}

\emph{Justification}: While any finite prefix can be generated, a single, finite-state TM must generate the entire infinite sequence. An infinite binary step sequence could, for example, encode the solution to the Halting Problem by having its $m$-th write operation depend on the halting behavior of the $m$-th Turing machine. Such a sequence, while satisfying the local kinematic constraints, would not be computable and thus not generable by any single TM.

\section{Connections and Open Questions}

\paragraph{Alternative Encodings.} 
While we use right-to-left binary encoding, other choices (left-to-right, different bases, position-aware encodings) would yield different sequences and characterizations. Understanding the relationships between these encodings may reveal invariant properties of the underlying computation.

\paragraph{Complexity of Generation.} 
Among all TMs that can generate a given finite binary step sequence, what is the minimum number of states required? This question connects the descriptive complexity of the sequence to the state complexity of the generating machine.

\section{Conclusion}

By interpreting Turing machine tapes as binary numbers, we have defined a class of integer sequences---binary step sequences---that directly reflect the locality and mechanical constraints of computation. We have provided a complete and rigorous characterization for all finite sequences of this type. The central open problem remains the characterization of TM-generable infinite sequences, which we conjecture is a proper subset of all infinite binary step sequences. We hope this work opens new avenues for analyzing computational processes through the lens of number theory, suggesting a deeper structure underlying the seemingly unpredictable behavior of Turing machines.

\begin{thebibliography}{10}

\bibitem{allouche2003}
J.-P. Allouche and J. Shallit.
\emph{Automatic Sequences: Theory, Applications, Generalizations}.
Cambridge University Press, 2003.

\bibitem{marxen1990}
H. Marxen and J. Buntrock.
Attacking the Busy Beaver 5.
\emph{Bulletin of the EATCS}, 40:247--251, 1990.

\bibitem{michel2015}
P. Michel.
Problems in number theory from busy beaver competition.
\emph{arXiv:1311.1029}, 2015.

\bibitem{michel2017}
P. Michel.
The Busy Beaver Competition: A historical survey.
\emph{arXiv:0906.3749v2}, 2017.

\bibitem{shallit2022}
J. Shallit.
\emph{The Logical Approach to Automatic Sequences}.
Cambridge University Press, 2022.

\bibitem{turing1936}
A. M. Turing.
On computable numbers, with an application to the Entscheidungsproblem.
\emph{Proceedings of the London Mathematical Society}, 42(2):230--265, 1936.

\end{thebibliography}

\end{document}